#!/usr/bin/env bash
# Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0
set -u

MY_VERSION="1.0"
MY_NAME="nitro-evault"
MY_DESC="Nitro eVault management tool"
EVAULT_DIRECTORY="evault"
EVAULT_IMAGE="evault.eif"
NITRO_CLI="nitro-cli"
NITRO_VTOKEN="nitro-vtoken"
NITRO_CONFIG="nitro-cli-config.sh"
PROVISIONING_SERVER_PORT="10000"
AF_UNIX_RPC_FILE="/vtok/build/rpc.sock"
P11KIT_SERVER_PORT="9999"
DEFAULT_CPUS="2"
DEFAULT_MEMORY="256"

PKCS11_CONFIG_FILE="/etc/pkcs11/modules/evault.module"
PKCS11_PROVIDER_NAME="libvtok_p11.so"

AWS_REGION=
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_SESSION_TOKEN=


USAGE="\
$MY_NAME v$MY_VERSION - $MY_DESC
Usage: $(basename "$0") <command> [arguments]

Commands:

    start           Start the eVault enclave
        --cpu-count     The number of vCPUs to allocate for the eVault enclave.
        --memory        eVault enclave memory size, in MiB.

    init-token      Initialize an eVault token
        --key-db        The database file to be loaded into eVault for this token.
                        See \`evault-db help\` for information on generating this file.
        --label         The token PKCS#11 label; a UTF-8 string, between 1 and 32 bytes long.
                        Note: the token label must be unique across all eVault tokens.
        --pin           The PIN that should be used to secure access to this token;
                        a UTF-8 string, between 4 and 64 bytes long.

    refresh-token   Refresh an eVault token
        --label         Token label.
        --pin           The PIN used to access this token (previously set via an init-token
                        operation).

    release-token   Release an eVault token
        --label         The label that (uniquely) identifies the token to be released.
        --pin           The PIN used to access this token (previously set via an init-token
                        operation).

    describe-device Get information about the eVault device

    describe-token  Get information about an eVault vToken
        --label         The label that (uniquely) identifies the token to be released.
        --pin           The PIN used to access this token (previously set via an init-token
                        operation).

    stop            Stop the eVault enclave
"

# Get the eVault image path
#
get_image_path() {
    local image_path
    image_path="$HOME/$EVAULT_DIRECTORY/$EVAULT_IMAGE"
    echo "$image_path"
}

# Ensure the eVault image is present
#
ensure_image_installed() {
    local path
    path=$(get_image_path)

    if [ ! -f "$path" ]; then
        die "The Nitro Evault enclave image is missing. Aborting."
    fi
}

# Ensure nitro-cli tool is installed
#
ensure_nitro_cli() {
    which "$NITRO_CLI" > /dev/null 2>&1
    ok_or_die "The nitro-cli tool is not installed. Aborting."
}

# Ensure nitro-vtoken tool is installed
#
ensure_nitro_vtoken() {
    which "$NITRO_VTOKEN" > /dev/null 2>&1
    ok_or_die "The nitro-vtoken tool is not installed. Aborting."
}

# Ensure we have a valid set of AWS credentials (fetched from IMDS)
#
ensure_aws_creds() {
    creds_json=$(curl -fs \
        http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance)
    ok_or_die "Unable to find instance role credentials." \
        "Please make sure you are running $MY_NAME on an EC2 instance with the correct IAM role assigned."
    AWS_REGION="us-east-1"
    AWS_ACCESS_KEY_ID=$(echo "$creds_json" | jq -er ".AccessKeyId")
    ok_or_die "Unable to parse instance role credentials."
    AWS_SECRET_ACCESS_KEY=$(echo "$creds_json" | jq -er ".SecretAccessKey")
    ok_or_die "Unable to parse instance role credentials."
    AWS_SESSION_TOKEN=$(echo "$creds_json" | jq -er ".Token")
    ok_or_die "Unable to parse instance role credentials."
}

# Keep p11-kit client-side configuration in sync with the current
# eVault enclave vsock CID.
#
create_pkcs11_config() {
    local cid
    cid=$("$NITRO_CLI" describe-enclaves | jq '.[] | .EnclaveCID')
    ok_or_die "Cannot get eVault enclave CID."

    conf="remote:vsock:cid=$cid;port=$P11KIT_SERVER_PORT"
    conf="$conf\nmodule:$PKCS11_PROVIDER_NAME"

    {
        mkdir -p $(dirname "$PKCS11_CONFIG_FILE") \
            && echo -e "$conf" > "$PKCS11_CONFIG_FILE"
    } 2> /dev/null
    [[ $? -eq 0 ]] && [ -t 1 ] || {
        say "$MY_NAME requires permission to create $PKCS11_CONFIG_FILE"
        sudo mkdir -p "$(dirname "$PKCS11_CONFIG_FILE")" \
            && { echo -e "$conf" | sudo tee  "$PKCS11_CONFIG_FILE"; } > /dev/null
    }
    ok_or_die "Cannot write PKCS#11 eVault config to $PKCS11_CONFIG_FILE"
    say "Successfully created PKCS#11 config at $PKCS11_CONFIG_FILE"
}

# Cleanup module configuration
#
remove_pkcs11_config() {
    rm -f "$PKCS11_CONFIG_FILE" 2> /dev/null
    [[ $? -eq 0 ]] && [ -t 1 ] || {
        say "$MY_NAME requires permission to remove $PKCS11_CONFIG_FILE"
        sudo rm -f "$PKCS11_CONFIG_FILE"
    }
    [[ $? -eq 0 ]] || say_warn "Unable to remove $PKCS11_CONFIG_FILE"
}

# Prepare eVault enclave memory and cpu configuration
#
nitro_cli_config() {
    # Tool is under <nitro-cli-install-dir>/tools/nitro-cli-config.sh
    local full_path
    full_path=$(which "$NITRO_CONFIG")
    local config_path
    config_path=${full_path%/tools/"$NITRO_CONFIG"}

    if [ ! -d "$config_path" ]; then
        die "Cannot find the nitro-cli-config install directory."
    fi

    local cpu_count="$1"
    local memory="$2"

    # Use the install directory
    "$NITRO_CONFIG" -d "$config_path" -b -i -m "$memory" -t "$cpu_count" > /dev/null 2>&1
    ok_or_die "Cannot initialize the nitro-cli environment."
}

# Start the eVault
#
cmd_start() {
    ensure_nitro_cli
    ensure_image_installed

    if [ "$#" -eq 4 ]; then
        while [[ "$#" -gt 0 ]]; do
        case $1 in
            --cpu-count) cpu_count="$2"; shift ;;
            --memory) memory="$2"; shift ;;
            *) cmd_help; die "Invalid arguments. Please use \`$MY_NAME help\` for help.";;
        esac
        shift
    done
    elif [ "$#" -eq 0 ]; then
        # Default minimal eVault enclave configuration
        cpu_count="$DEFAULT_CPUS"
        memory="$DEFAULT_MEMORY"
    else
        die "Invalid arguments. Please use \`$MY_NAME help\` for help."
    fi

    # Check if eVault is already running
    local id
    id=$("$NITRO_CLI" describe-enclaves | jq -r '.[] | .EnclaveID')
    if [ ! -z "$id" ]; then
        die "The eVault enclave is already running."
    fi

    # Configure the nitro-cli environment
    nitro_cli_config "$cpu_count" "$memory"

    # Spawn the eVault enclave
    local eif_path
    eif_path=$(get_image_path)
    "$NITRO_CLI" run-enclave --cpu-count "$cpu_count" --memory "$memory" --eif-path "$eif_path" > /dev/null 2>&1
    ok_or_die "Cannot start the eVault enclave"

    say "Successfully started the eVault enclave."

    create_pkcs11_config
}

# Stop the eVault
#
cmd_stop() {
    ensure_nitro_cli

    if [ "$#" -ne 0 ]; then
        die "Invalid arguments. Please use \`$MY_NAME help\` for help."
    fi

    local id
    id=$("$NITRO_CLI" describe-enclaves | jq -r '.[] | .EnclaveID')
    if [ -z "$id" ]; then
        die "No eVault enclave is currently running."
    fi

    "$NITRO_CLI" terminate-enclave --enclave-id "$id" > /dev/null 2>&1
    ok_or_die "Cannot stop the eVault enclave."

    say "Successfully stopped the eVault enclave."

    remove_pkcs11_config
}

# Issue a RPC call
#
execute_rpc() {
    if [ "$#" -ne 1 ]; then
        die "Bad execute_rpc() call."
    fi

    local rpc_request="$1"

    # Construct the server address
    if test -S "$AF_UNIX_RPC_FILE"; then
        # AF_UNIX transport (dev environment)
        server_path="unix:$AF_UNIX_RPC_FILE"
    else # AF_VSOCK transport
        local cid
        cid=$("$NITRO_CLI" describe-enclaves | jq '.[] | .EnclaveCID')
        if [ -z "$cid" ]; then
            die "The eVault enclave is no longer running."
        fi
        server_path="vsock:$cid:$PROVISIONING_SERVER_PORT"
    fi

    # Execute the RPC
    local result
    result=$(echo "$rpc_request" | "$NITRO_VTOKEN" raw-rpc --server "$server_path")
    echo "$result"
}

# Initialize a token
#
cmd_init-token() {
    ensure_nitro_vtoken
    ensure_aws_creds

    if [ "$#" -ne 6 ]; then
        die "Invalid arguments. Please use \`$MY_NAME help\` for help."
    fi

    while [[ "$#" -gt 0 ]]; do
        case $1 in
            --key-db) key_db="$2"; shift ;;
            --label) label="$2"; shift ;;
            --pin) pin="$2"; shift ;;
            *) cmd_help; die "Invalid arguments. Please use \`$MY_NAME help\` for help.";;
        esac
        shift
    done

    # The key DB file
    if [ ! -f "$key_db" ]; then
        die "Cannot find the key database file"
    fi

    local keys
    keys="$(<"$key_db")"

    # The envelope key
    local envelope_key
    envelope_key=$( jq -Rn \
                --arg a "$AWS_ACCESS_KEY_ID" \
                --arg b "$AWS_SECRET_ACCESS_KEY" \
                --arg c "$AWS_SESSION_TOKEN" \
                --arg d "$AWS_REGION" \
                '{Kms: {access_key_id: $a, secret_access_key: $b, session_token: $c, region: $d}}')
    ok_or_die "Cannot construct Kms credentials."

    # AddToken RPC
    local rpc_request
    rpc_request=$( jq -Rn \
            --arg a "$label" \
            --arg b "$pin" \
            --argjson c "$envelope_key" \
            --argjson d "$keys" \
            '{AddToken: {token: {label: $a, pin: $b, envelope_key: $c, keys: [ $d ]}}}')
    ok_or_die "Cannot construct eVault token initialization message."

    # Execute RPC
    local result
    result=$(execute_rpc "$rpc_request")
    echo "$result" | jq
}

# Refresh a token
#
cmd_refresh-token() {
    ensure_nitro_vtoken
    ensure_aws_creds

    if [ "$#" -ne 4 ]; then
        die "Invalid arguments. Please use \`$MY_NAME help\` for help."
    fi

    while [[ "$#" -gt 0 ]]; do
        case $1 in
            --label) label="$2"; shift ;;
            --pin) pin="$2"; shift ;;
            *) cmd_help; die "Invalid arguments. Please use \`$MY_NAME help\` for help.";;
        esac
        shift
    done

    # The envelope key
    local envelope_key
    envelope_key=$( jq -Rn \
                --arg a "$AWS_ACCESS_KEY_ID" \
                --arg b "$AWS_SECRET_ACCESS_KEY" \
                --arg c "$AWS_SESSION_TOKEN" \
                --arg d "$AWS_REGION" \
                '{Kms: {access_key_id: $a, secret_access_key: $b, session_token: $c, region: $d}}')
    ok_or_die "Cannot construct Kms credentials."

    # RefreshToken RPC
    local rpc_request
    rpc_request=$( jq -Rn \
            --arg a "$label" \
            --arg b "$pin" \
            --argjson c "$envelope_key" \
            '{RefreshToken: {label: $a, pin: $b, envelope_key: $c}}')
    ok_or_die "Cannot construct eVault token refresh message."

    # Execute RPC
    local result
    result=$(execute_rpc "$rpc_request")
    echo "$result" | jq
}

# Release a token
#
cmd_release-token() {
    ensure_nitro_vtoken

    if [ "$#" -ne 4 ]; then
        die "Invalid arguments. Please use \`$MY_NAME help\` for help."
    fi

    while [[ "$#" -gt 0 ]]; do
        case $1 in
            --label) label="$2"; shift ;;
            --pin) pin="$2"; shift ;;
            *) cmd_help; die "Invalid arguments. Please use \`$MY_NAME help\` for help.";;
        esac
        shift
    done

    # RemoveToken RPC
    local rpc_request
    rpc_request=$( jq -Rn \
            --arg a "$label" \
            --arg b "$pin" \
            '{RemoveToken: {label: $a, pin: $b}}')
    ok_or_die "Cannot construct eVault token release message."

    # Execute RPC
    local result
    result=$(execute_rpc "$rpc_request")
    echo "$result" | jq
}

# Get the device status
#
cmd_describe-device() {
    ensure_nitro_vtoken

    if [ "$#" -ne 0 ]; then
        die "Invalid arguments. Please use \`$MY_NAME help\` for help."
    fi

    # Execute RPC
    local result
    result=$(execute_rpc "{\"DescribeDevice\": null}")
    echo "$result" | jq
}

# Describe a token
#
cmd_describe-token() {
    ensure_nitro_vtoken

    if [ "$#" -ne 4 ]; then
        die "Invalid arguments. Please use \`$MY_NAME help\` for help."
    fi

    while [[ "$#" -gt 0 ]]; do
        case $1 in
            --label) label="$2"; shift ;;
            --pin) pin="$2"; shift ;;
            *) cmd_help; die "Invalid arguments. Please use \`$MY_NAME help\` for help.";;
        esac
        shift
    done

    # DescribeToken RPC
    local rpc_request
    rpc_request=$( jq -Rn \
            --arg a "$label" \
            --arg b "$pin" \
            '{DescribeToken: {label: $a, pin: $b}}')
    ok_or_die "Cannot construct eVault describe token message."

    # Execute RPC
    local result
    result=$(execute_rpc "$rpc_request")
    echo "$result" | jq
}

# Exit with an error message and (optional) code
# Usage: die [-c <error code>] <error message>
#
die() {
    code=1
    [[ "$1" = "-c" ]] && {
        code="$2"
        shift 2
    }
    say_err "$@"
    exit "$code"
}

# Exit with an error message if the last exit code is not 0
#
ok_or_die() {
    code=$?
    [[ $code -eq 0 ]] || die -c $code "$@"
}

# Send an error-decorated text message to stderr
#
say_err() {
    [ -t 2 ] && [ -n "$TERM" ] \
        && echo "$(tput setaf 1)[$MY_NAME] $*$(tput sgr0)" 1>&2 \
        || echo "[$MY_NAME] $*" 1>&2
}

# Send a warning-decorated text message to stderr
#
say_warn() {
    [ -t 2 ] && [ -n "$TERM" ] \
        && echo "$(tput setaf 3)[$MY_NAME] $*$(tput sgr0)" 1>&2 \
        || echo "[$MY_NAME] $*" 1>&2
}

# Send a decorated message to stdout, followed by a new line
#
say() {
    [ -t 1 ] && [ -n "$TERM" ] \
        && echo "$(tput setaf 2)[$MY_NAME]$(tput sgr0) $*" \
        || echo "[$MY_NAME] $*"
}

# Print usage
#
cmd_help() {
    echo "$USAGE"
}

main() {

    if [ "$#" -eq 0 ]; then
        die "Invalid arguments. Please use \`$MY_NAME help\` for help."
    fi

    cmd="$1"

    declare -f "cmd_$cmd" > /dev/null
    ok_or_die "Unknown command: $1. Please use \`$MY_NAME help\` for help."

    cmd_"$@"
}

main "${@}"
